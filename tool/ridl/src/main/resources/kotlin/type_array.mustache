{{#size}}
public class {{name}}(private val items: Array<{{item}}>) : _Array<{{item}}>(items), {{parent}} {

    override fun write(writer: IonWriter) {
        {{#tag}}
        writer.stepIn(IonType.SEXP)
        writer.writeInt(TAG)
        {{/tag}}
        writer.stepIn(IonType.LIST)
        for (item in items) {
            {{#write}}
            writer.{{write}}
            {{/write}}
            {{^write}}
            item.write(writer)
            {{/write}}
        }
        writer.stepOut()
        {{#tag}}
        writer.stepOut()
        {{/tag}}
    }

    companion object {

        {{#tag}}
        public const val TAG: Long = {{.}}
        {{/tag}}

        @JvmStatic
        fun read(reader: IonReader): {{name}} {
            var i = 0
            val n = {{size}}
            val items = arrayOfNulls<{{item}}>(n)
            reader.stepIn()
            while (reader.next() == IonType.{{itemIon}}) {
                if (i == n) {
                    error("Expected array of len `$n`, found len $i")
                }
                {{#read}}
                items[i++] = reader.{{read}}
                {{/read}}
                {{^read}}
                items[i++] = {{item}}.read(reader)
                {{/read}}
            }
            if (i != n) {
                error("Expected array of len `$n`, found len $i")
            }
            reader.stepOut()
            return {{name}}(items.requireNoNulls())
        }
    }
}
{{/size}}
{{^size}}
public class {{name}}(private val items: ArrayList<{{item}}>) : _ArrayList<{{item}}>(items), {{parent}} {

    override fun write(writer: IonWriter) {
        {{#tag}}
        writer.stepIn(IonType.SEXP)
        writer.writeInt(TAG)
        {{/tag}}
        writer.stepIn(IonType.LIST)
        for (item in items) {
            {{#write}}
            writer.{{write}}
            {{/write}}
            {{^write}}
            item.write(writer)
            {{/write}}
        }
        writer.stepOut()
        {{#tag}}
        writer.stepOut()
        {{/tag}}
    }

    companion object {

        {{#tag}}
        public const val TAG: Long = {{.}}
        {{/tag}}

        @JvmStatic
        fun read(reader: IonReader): {{name}} {
            val items = arrayListOf<{{item}}>()
            assert(reader.type == IonType.LIST)
            reader.stepIn()
            while (reader.next() == IonType.{{itemIon}}) {
                {{#read}}
                items.add(reader.{{read}})
                {{/read}}
                {{^read}}
                items.add({{item}}.read(reader))
                {{/read}}
            }
            reader.stepOut()
            return {{name}}(items)
        }
    }
}
{{/size}}
