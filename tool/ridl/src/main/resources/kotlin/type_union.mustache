public sealed interface {{name}} : {{parent}} {

    {{#variants}}
    {{#type}}
    {{>type}}
    {{/type}}
    {{/variants}}


    companion object {

        {{#tag}}
        public const val TAG: Long = {{.}}

        internal fun stepIn(writer: IonWriter) {
            {{parent}}.stepIn(writer)
            writer.stepIn(IonType.SEXP)
            writer.writeInt(TAG)
        }

        internal fun stepOut(writer: IonWriter) {
            writer.stepOut()
            {{parent}}.stepOut(writer)
        }
        {{/tag}}
        {{^tag}}
        internal fun stepIn(writer: IonWriter) {
            // no-op
        }

        internal fun stepOut(writer: IonWriter) {
            // no-op
        }
        {{/tag}}

        @JvmStatic
        public fun read(reader: IonReader): {{name}} {
            assert(reader.type == IonType.SEXP)
            reader.stepIn()
            assert(reader.next() == IonType.INT)
            val tag: Long = reader.longValue()
            reader.next()
            val variant =  when (tag) {
                {{#variants}}
                {{name}}.TAG -> {{name}}.read(reader)
                {{/variants}}
                else -> error("Invalid tag `$tag` on union type `{{name}}`")
            }
            reader.stepOut()
            return variant
        }
    }
}
