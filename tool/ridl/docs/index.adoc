= RIDL — Interface Definition Language
:toc:
:toc-title: Page Contents
:sectlinks:
:table-caption!:

== About

This document defines an interface definition language for types whose values can be serialized as Ion. It is intended to be a simple and high-level modeling language whose definitions trivially map to link:https://survey.stackoverflow.co/2023/#most-popular-technologies-language-prof[key languages] in the link:https://en.wikipedia.org/wiki/List_of_C-family_programming_languages[C-family] such as C, C++, Go, Rust, and Java.

=== Supported Languages

* xref:languages/isl.adoc[Ion Schema]
* xref:languages/kotlin.adoc[Kotlin]

=== License

This project is licensed under the Apache-2.0 License.

== Interface Definition Language

=== Notation

This document uses the xref:https://github.com/antlr/antlr4/blob/master/doc/grammars.md[ANTLR grammar notation] to define the IDL.

=== Example

This example showcases the modeling language.

[source]
----
type uuid byte[16]; // fixed-length array of bytes

type currency enum { USD, EUR, JPY, GBP, CHF };

type coordinate struct {
    x: int32,
    y: int32,
    z: int32,
};

type number union {
    int: int32,
    long: int64,
    float: float32,
    double: float64
};
----

=== Document

[source,antlr]
----
document
    : body EOF
    ;

body
    : include* definition*
    ;

include
    : 'include' string ('as' idenitifier)? ';'
    ;

definition
    : 'type' identifier type ';'
    | 'namespace' identifier '{' body '}'
    ;

identifier: [a-z][a-z0-9_]*;

type
    : reference
    | primitive
    | array
    | struct
    | union
    | enum
    | unit
    ;

reference
    : '::'? (identifier '::')* identifier
    ;
----

=== Primitive

[source,antlr]
----
primitive
    : 'void'
    | 'bool'
    | 'int32'   // 32-bit signed integer
    | 'int64'   // 64-bit signed integer
    | 'float32' // IEEE 754 (32 bit)
    | 'float64' // IEEE 754 (64 bit)
    | 'string'  // Character sequence of variable length
    | 'byte'    // Byte
    | 'bytes'   // Byte sequence of variable length
    ;
----

=== Array

Arrays represent either fixed-length or variable-length sequences; an array type is variable-length if no size is given.

NOTE: Add a note about why byte/bytes vs byte[n], byte[], and bytes as Ion blob with length constraint.

[source,antlr]
----
array: type '[' size=int? ']';
----

.Examples
[source,ridl]
----
type uuid byte[16]; // fixed-length array
type sha1 byte[20]; // ''

type nums int32[];  // variable-length array

// Equivalent in Ion encoding
byte  <-> byte[1]
bytes <-> byte[]
----

=== Struct

[source,antlr]
----
struct: 'struct' '{' field (',' field)* ','? '}';

field: identitifer ':' type;
----

.Example
[source,ridl]
----
type decimal struct {
    coefficient: int64,
    exponent: int32,
};

type coordinates struct {
    lat: decimal,
    lon: decimal,
};
----

=== Union

[source,antlr]
----
union
    : 'union' '{' variant (',' variant)* ','? '}'
    ;

variant
    : identifier ':' type
    ;
----

.Example
[source]
----
type my_union union {

    variant_a: struct {
        x: int32,
        y: int32,
    },

    variant_b: stuct {
        u: int32,
        v: int32,
    },
};
----

=== Enum

[source,antlr]
----
enum : 'enum' { enumerator (',' enumerator)* '}' ;

enumerator : [A-Z]+ ;
----

.Example
[source,ridl]
----
type my_enum enum { A, B, C };
----

==== Unit

Define a type which is represented by only its name. This is like an empty struct and is represented by an Ion symbol.

[source,antlr]
----
unit : 'unit';
----

.Example
[source]
----
type my_singleton unit;
----

=== Include

An include statement is used to bring all type definitions from another source into the current namespace. It is effectively a pre-processing copy-paste of the included source.

.Include Example
[source]
----
// file1.ridl
type a int32[];

// file2.ridl
include file1.ridl;
type b enum { X, Y };

// > ridl -I . file2.ridl -o types.ridl
// > cat types.ridl
type a int32[];
type b enum { X, Y };
----

=== Namespace

Namespaces allow grouping of type names to preventing name conflicts. The syntax and behavior match typedef in C++ namespaces and the Type Namespace of Rust. In RIDL, there is only one _type_ of namespace i.e. the _names_ of namespaces and the _names_ types of occupy the same space.

.Namespaces in C++ (Typedef Namespace)
> Namespaces provide a method for preventing name conflicts in large projects.
Entities declared inside a namespace block are placed in a namespace scope, which prevents them from being mistaken for identically-named entities in other scopes.
>
> Entities declared outside all namespace blocks belong to the global namespace. The global namespace belongs to the global scope, and can be referred to explicitly with a leading `::`. While it has no declaration, the global namespace is not an unnamed namespace. 
>
> -- link:https://en.cppreference.com/w/cpp/language/namespace[]

.Namespaces in Rust (Type Namespace)
> A namespace is a logical grouping of declared names. Names are segregated into separate namespaces based on the kind of entity the name refers to. Namespaces allow the occurrence of a name in one namespace to not conflict with the same name in another namespace.
>
> Within a namespace, names are organized in a hierarchy, where each level of the hierarchy has its own collection of named entities.
> -- link:https://doc.rust-lang.org/reference/names/namespaces.html[]

== Amazon Ion

This section defines how type definitions are mapped to Ion values as well as Ion Schema 2.0. For details on Ion, see xref:https://amazon-ion.github.io/ion-docs/docs/spec.html[Ion Specification].

=== Ion Encoding

This section defines how concrete values of RIDL-defined types are encoded as Ion values.

.Ion Reference
[cols="1s,1s"]
|===
s| link:https://amazon-ion.github.io/ion-docs/docs/spec.html[Textual]
s| link:https://amazon-ion.github.io/ion-docs/docs/binary.html[Binary]
|===

==== Primitives

Primitive values are encoded via the Ion types shown below.

|===
| RIDL Primitive | Ion Primitive

| bool | bool
| int32 | int
| int64 | int
| float32 | float
| float64 | float
| string | string
| byte | blob
| bytes | blob

|===

==== Arrays

Array values are encoded as Ion lists.

==== Struct

A struct is encoded as an untagged Ion s-expression — see note on records, products, packed structs etc. This basic text encoding translates to a similar Ion binary encoding to that of both Protobuf and Avro [1]. The omission of struct type annotations is typical as concrete types are given during deserialization as seen in Jackson JSON / Moshi / Rust Serde JSON.

.Example
[source]
----
// Example type
type my_struct {
    a: int32,
    b: int32,
};

// Example value for `my_struct`
// { a: 1, b: 2 }

// Ion Encoding
(1,2)
----

.Namespaced Example
[source]
----
// Example type (namespaced)
namespace foo {
    type bar struct {
        x: bool,
        y: bool,
    }
}

// Example value for `foo::bar`
// { x: true, y: false }

// Ion Encoding
(true,false)
----

NOTE: Related topics which are illustrative here are link:https://ziglang.org/documentation/master/#packed-struct[Zig packed structs] and link:https://en.wikipedia.org/wiki/Product_type[product] types vs. link:https://en.wikipedia.org/wiki/Record_(computer_science)[record] types. The crux here is asking which algebraic type we _want_ struct to represent in RIDL, and will there be a tuple type? This proposal aligns with Zig's packed struct which is much like a product type where names are discarded and fields are accessed in the order they are declared. I'm eager to discuss this, but consider a definitive decision out of scope for version 1.

.Notes
* https://protobuf.dev/programming-guides/encoding/
* https://avro.apache.org/docs/1.11.1/specification/#data-serialization-and-deserialization

==== Union

A union type is encoded as the encoding of its concrete type.

.Example
[source]
----
type my_union union {
    foo: int32,
    bar: struct { x: int32, y: int32 },
};

// Foo Value, 3
// Bar Value,  { x: 1, y: 2 }

// Foo Encoding — tag 0
(0 3)

// Bar Encoding — tag 1
(1 (1 2))
----

==== Enum

An enum is serialized to Ion as a symbol.

.Example
[source]
----
// Definition
type my_enum enum { A, B, C };

// Value
// B

// Ion Encoding
B
----

==== Unit

A unit is serialized to Ion as the symbol `$unit`. Add note as to why or why not this exists.

.Example
[source]
----
// Types

type my_unit unit;

namespace foo {
    type my_unit unit;
}

// Ion Encodings
$unit
----

=== Ion Schema

This section describes how RIDL type definitions are mapped to Ion Schema. I use `<PLACEHOLDER>` to represent a placeholder called `PLACEHOLDER`, and the special placeholder `<NAME>` and `'<..NAME>'` to be an unqualified and fully-qualified type name respectively. 

// For example,

// [source,ridl]
// ----
// namespace <NS1> {
//     namespace <NS2> {
//         type <NAME> foo;
//     }
// }
// ----

// The value of `'<..NAME>' is `<NS1>::<NS2>::<NAME>`.

==== Primitives

Primitives are effectively aliases for the Ion primitive types; only `int32`, `float32`, and `byte` require constraints.

[source,ion]
----
type::{
    name: void,
    type: nothing,
}

type::{
    name: '::int32',
    type: int,
    valid_values: range::[
        -2_147_483_648, // -(2^31)
        +2_147_483_647, // 2^31 - 1
    ]
}

type::{
    name: int64,
    type: int,
    valid_values: range::[
        −9_223_372_036_854_775_808, // -(2^63)
        +9_223_372_036_854_775_807, // 63^2 - 1
    ],
}

type::{
    name: float32,
    type: float,
    valid_values: range::[], // ?
}

type::{
    name: float64,
    type: float,
}

type::{
    name: byte,
    type: blob,
    byte_length: 1,
}

type::{
    name: bytes,
    type: blob,
}
----

==== Arrays


**Fixed Length**

[source,ridl]
----
type <NAME> <TYPE>[<SIZE>];
----

[source,ion]
----
type::{
    name: '<..NAME>',
    type: list,
    container_length: <SIZE>,
}
----

**Variable Length**
[source,ion]
----
type::{
    name: '<..NAME>',
    type: list,
}
----

==== Struct

[source,ridl]
----
type <NAME> struct {
    <F_1>: <T_1>,
    ...
    <F_N>: <T_N>,
};
----

[source,ion]
----
type::{
    name: '<..NAME>',
    type: sexp,
    container_length: <N>,
    ordered_elements: [
        <T_1>,
        ...,
        <T_N>,
    ],
}
----

NOTE: Each `<T_i>` which is an inline type definition is defined before the outer type with the inline type's name `'<..NAME>'::<F_i>`.

==== Union

[source,ridl]
----
type <NAME> union { 
    <V_1>: <T_1>,
    ...
    <V_N>: <T_N>,
}
----

[source,ion]
----
type::{
    name: '<..V_1>',
    type: <T_1>,
}

...

type::{
    name: '<..V_N>',
    type: <T_N>,
}

type::{
    name: '<..NAME>',
    type: sexp,
    ordered_elements: [
      {
        type: int,
        valid_values: range::[0, exclusive::<N>],
      },
      {
        one_of: [ <T_1>, ..., <T_N> ],
      }
    ]
}
----

==== Enum

[source,ridl]
----
type <NAME> enum { <E_1>, ..., <E_N> };
----

[source,ion]
----
type::{
    name: '<..NAME>',
    type: symbol,
    valid_values: [ <E_1>, ..., <E_N> ],
}
----

==== Unit

[source,ridl]
----
type <NAME> unit;
----

[source,ion]
----
type::{
    name: '<..NAME>',
    type: symbol,
    valid_values: [ unit ],
}
----

== Appendix

=== A1 — Prior Art Comparisons

PLACEHOLDER

=== A2 — Complete Grammar

[source,antlr4]
----
grammar RIDL;

document
  : body EOF
  ;

body
  : include* definition*
  ;

include
  : INCLUDE STRING (AS? NAME)
  ;

definition
  : TYPE NAME type SEMICOLON              #definitionType
  | NAMESPACE NAME L_BRACE body R_BRACE   #definitionNamespace
  ;

type
  : typeNamed
  | typePrimitive
  | typeArray
  | typeStruct
  | typeUnion
  | typeEnum
  | typeUnit
  ;

typeNamed
  : NAME
  ;

typePrimitive
  : T_BOOL
  | T_INT32
  | T_INT64
  | T_FLOAT32
  | T_FLOAT64
  | T_STRING
  | T_BYTE
  | T_BYTES
  ;

typeArray
  : (typeNamed|typePrimitive) L_BRACKET size=INTEGER? R_BRACKET
  ;

typeStruct
  : STRUCT L_BRACE typeStructField (COMMA typeStructField)* COMMA? R_BRACE
  ;

typeStructField
  : NAME COLON type
  ;

typeUnion
  : UNION L_BRACE typeUnionVariant+ R_BRACE
  ;

typeUnionVariant
  : NAME type SEMICOLON
  ;

typeEnum
  : ENUM L_BRACE ENUMERATOR (COMMA ENUMERATOR)* R_BRACE
  ;

typeUnit
  : UNIT
  ;

AS: 'as';
INCLUDE: 'include';
NAMESPACE: 'namespace';
TYPE: 'type';

T_BOOL: 'bool';
T_INT32: 'int32';
T_INT64: 'int64';
T_FLOAT32: 'float32';
T_FLOAT64: 'float64';
T_STRING: 'string';
T_BYTE: 'byte';
T_BYTES: 'bytes';

ARRAY: 'array';
STRUCT: 'struct';
UNION: 'union';
ENUM: 'enum';
UNIT: 'unit';

COMMA: ',';
COLON: ':';
SEMICOLON: ';';
L_ANGLE: '<';
R_ANGLE: '>';
L_PAREN: '(';
R_PAREN: ')';
L_BRACE: '{';
R_BRACE: '}';
L_BRACKET: '[';
R_BRACKET: ']';

NAME
  : [a-z][a-z0-9_]*
  ;

INTEGER
  : [0-9]+
  ;

ENUMERATOR
  : [A-Z][A-Z0-9_]+
  ;

STRING
  : '"' (~('"' | '\\' | '\r' | '\n') | '\\' ('"' | '\\'))* '"'
  ;

COMMENT_LINE
  : '//' ~[\r\n]* '\r'? '\n'? -> skip
  ;

COMMENT_BLOCK
  : '/*' .*? '*/' -> skip
  ;

WS
  : [ \r\n\t]+ -> skip
  ;

UNRECOGNIZED
  : .
  ;
----

==== Reserved Words

[source]
----
type
namespace
include
bool
int32
int64
float32
float64
string
byte
bytes
array
struct
union
enum
unit
----

=== A3 — Editor Configuration

**Intellij**
[source]
----
1. CMD + ,
2. Editor > File Types
3. CMD + N
4. Add RIDL:

    Name: RIDL
    Description: RIDL
    Line comment: //
    [x] Support paired braces
    [x] Support paired brackets
    [x] Support paired parents
    Keywords:
        type
        namespace
        include
        bool
        int32
        int64
        float32
        float64
        string
        byte
        bytes
        array
        struct
        union
        enum
        unit
----

=== A4 — FAQs

. **Why not Ion Schema?** — RIDL is designed for modeling types definitions rather than the Ion encoding itself. The RIDL library defines _an_ Ion encoding which in turn has its own Ion Schema. For example, Smithy and OpenAPI define higher-level types whereas JSON Schema defines the actual JSON values themselves. Likewise, this IDL defines high-level types which have an Ion serialization; that which can be defined in Ion Schema.
Additionally, reducing the allowable type definitions greatly simplifies building the necessary tooling. You'll find the modeling capabilities are far less than that of Ion Schema, but are quite similar to the type modeling of OpenAPI / Swagger, Protobuf, Smithy, and Avro. This is a difficult question to articulate, and I am interested in discussing more. I believe reading this full document and seeing the mapping of RIDL types to Ion values and schema help illustrate the benefits of a higher-level language.
. **Why Ion over BSON?** — Ion is the initial wire format choice, but further testing of different wire formats will inform the backend. The JSON and

=== A5 — Prior Art

The syntax and primitive types are a distillation of the following languages and IDLs; please see the appendix for detailed comparisons.

.Syntax
* link:https://en.wikipedia.org/wiki/Typedef[C typedef]
* link:https://go.dev/ref/spec#Type_declarations[Go type declarations]
* link:https://doc.rust-lang.org/reference/items/type-aliases.html[Rust type aliases]

.Types
* link:https://avro.apache.org/docs/1.11.1/specification/#primitive-types[Avro Primitives]
* link:https://protobuf.com/docs/language-spec#field-types[Protobuf Scalars]
* link:https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-00#section-4.2.1[JSON Scalars]
* link:https://amazon-ion.github.io/ion-docs/docs/spec.html#primitive-types[Ion Primitives]
* link:https://smithy.io/2.0/spec/simple-types.html[Smithy Primitives]
* link:https://swagger.io/specification/#data-types[OpenAPI Types]

.IDLs
* link:https://avro.apache.org/docs/1.11.1/specification/[Avro]
* link:https://protobuf.com/docs/language-spec[Protobuf]
* link:https://swagger.io/specification/[OpenAPI/Swagger]
* link:https://smithy.io/2.0/index.html[Smithy]
* link:https://json-schema.org/draft/2020-12/json-schema-core[JSON Schema]
* link:https://amazon-ion.github.io/ion-schema/docs/isl-2-0/spec[Ion Schema]

