= PartiQL Logical Plan Interface: Version (1)
:toc:
:toc-title: Page Contents
:sectlinks:
:table-caption!:

== About

This document defines the V1 interface for PartiQL's https://en.wikipedia.org/wiki/Query_plan[Plan] representation. PartiQL's serialized plans are backwards-compatible — i.e. an older version of compiled PartiQL plans can be retargeted to a newer version without changing the query's semantics. Plans have a single major-version number which appears as the first operand of the top-level product type.

include::navigation.adoc[]

== Background

This document began in March of 2023 with an initial model of PartiQL's relational algebra. Based upon this model, the PartiQL Team implemented a compiler and evaluator. This document relfects the current relational algebra model in the xref:https://github.com/partiql/partiql-lang-kotlin/blob/partiql-eval/partiql-plan/src/main/resources/partiql_plan.ion[partiql-lang-kotlin 1.0] implementation.  

== Document (Top-Level)

Plans are encoded in a top-level object; for lack of a better name, we'll call this the "document".

.Document
[cols="1,1e,3",grid=rows,frame=all]
|===
| Property | Type | Description

| version
| int
| Plan version

| catalogs
| list<catalog>
| Catalog metadata

| statement
| statement
| Compiled PartiQL statement

|===

=== Catalogs

Catalogs within plans represent entities of the database catalogs that this query was planned against. This includes base tables and functions along with any user-defined metadata. 

.Catalog
[cols="1,1e,3",grid=rows,frame=all]
|===
| Property | Type | Description

| name
| string
| The catalogs name

| items
| list<item>
| Resolved catalog entities during query planning

|===

.Item Variants
[cols="1e,5a",grid=rows,frame=all]
|===

| value
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! path      ! list<string>  ! Path within the catalog
! type      ! type          ! The catalog value's type
!===

| fn
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! path      ! list<string>  ! Path within the catalog
! specific  ! string        ! Operator specific identifier
!===

| agg
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! path      ! list<string>  ! Path within the catalog
! specific  ! string        ! Operator specific identifier
!===

|===

== Types

.Type Variants
[cols="1e,5a",grid=rows,frame=all]
|===
| bool
| singleton

| int8
| singleton

| int16
| singleton

| int32
| singleton

| int64
| singleton

| big_int
| singleton

| big_decimal
| singleton

| decimal
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! precision ! int   ! Decimal precision
! scale     ! int   ! Decimal scale
!===

| float32
| singleton

| float64
| singleton

| char_fixed
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! length    ! int  ! Fixed length
!===

| char_varying
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! length    ! int  ! Max length
!===

| string
| singleton

| symbol
| singleton

| bit_fixed
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! length    ! int  ! Fixed length
!===

| bit_varying
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! length    ! int  ! Max length
!===

| binary
| singleton

| byte_fixed
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! length    ! int  ! Fixed length
!===

| byte_variable
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! length    ! int  ! Max length
!===

| blob
| singleton

| clob
| singleton

| date
| singleton

| time(p)
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! precision    ! int  ! Seconds precision
!===

| time_tz
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! precision    ! int  ! Seconds precision
! offset       ! (int,int)  ! Zone offset
!===

| time_arbitrary
| singleton

| timestamp
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! precision    ! int  ! Seconds precision
!===

| timestamp_tz
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! precision    ! int  ! Seconds precision
! offset       ! (int,int)  ! Zone offset
!===

| timestamp_arbitrary
| singleton

| interval
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! precision    ! int  ! Seconds precision
!===

| bag
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! items    ! type  ! Items type
!===

| list
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! items    ! type  ! Items type
!===

| sexp
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! items    ! type  ! Items type
!===

| struct
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! fields   ! list<(string,type)> ! Struct fields
! open     ! bool  ! True if open content struct
! ordered  ! bool  ! True if fields are ordered
! unique   ! bool  ! True if field key are unique
!===

| null
| singleton

| missing
| singleton

| union
|
[cols="1,1e,3",grid=rows,frame=none]
!===
s! Property  s! Type          s! Description
! types    ! list<type>  ! Types in the union
!===

|===

== Statements

A plan contains a single _statement_ which has many variants.

.Statement
[cols="1e,5a",grid=rows,frame=all]
|===
| Variant | Description

| query
| Query expression i.e. SELECT-FROM-WHERE

| insert | DML INSERT

| insert_value | DML INSERT VALUE

| upsert | DML UPSERT

| replace | DML REPLACE

| update | DML UPDATE

| remove | DML REMOVE

| delete | DML DELETE

| create_table | DDL CREATE TABLE

| create_index | DDL CREATE INDEX

| create_view
| DDL CREATE VIEW

| drop_table | DDL DROP TABLE

| drop_index | DLL DROP INDEX

2+a|

NOTE: This document's scope is limited to _query_ statements.

|===

=== Query

.Query
[cols="1,1e,3",grid=rows,frame=all]
|===
| Property | Type | Description


|===

== Operators

[#rex]
=== Rex

[#rex-summary]
.Rex Variants
[cols="1e,5a",grid=rows,frame=all]
|===

| lit
| ..

| var
| ..

| global
| ..

| path
| ..

| cast
| ..

| call
| ..

| switch
| ..

| collection
| ..

| struct
| ..

| pivot
| ..

| subquery
| ..

| select
| ..

| tuple_union
| ..

|===

==== Var

==== Literal

Literal expressions are simply xref:model.adoc#values[PartiQL Values].

==== Path

Path expressions contain a root and one or more steps. See the xref:https://partiql.org/concepts/paths.html[PartiQL Specification on Paths] for details on 

.Path Rex
[cols="1,1e,3",grid=rows,frame=all]
|===
| Property | Type | Description

| Root
| Rex
| Expression to navigate

| Step
| List<Step>
| Navigation Steps

|===

.Step Variants
[cols="1,5a",grid=rows,frame=all]
|===
| Variant | Definition

| Index
|
[cols="1,1e,3",grid=rows,frame=none]
!===
! Property ! Type ! Description

! Value ! Rex ! Index expression
!===

| Wildcard Variant
e| Singleton

| Unpivot Variant
e| Singleton

|===

==== Call

[NOTE,caption=signature]
====
_V^N^ → V_
====

[cols="1,1e,3",grid=rows,frame=all]
|===
| Property | Type | Description

| Identifier
| Symbol
| A collection value expression — e.g. bag or array

| Signature
| Function Signature
| Binding name for each value of the collection

| Arguments
| List<V>
| Binding name for the index of each value of the collection only if it is an array

|===

.Function Signature
[cols="1,1e,3",grid=rows,frame=all]
|===
| Property | Type | Description

| Argument Types
| List<T>
| A collection of argument types

| Return Type
| T
| Return type _T_

|===

==== Cast

.Cast Rex
[cols="1,1e,3",grid=rows,frame=all]
|===
| Property | Type | Description

| Rex
| Rex
| Expression to cast

| Type
| Type
| PartiQL Type to cast to

|===

==== Switch

.Switch Rex
[cols="1,1e,3",grid=rows,frame=all]
|===
| Property | Type | Description

| Match
| Rex
| Optional expression to match branch conditions

| Default
| Rex
| Optional default expression if no branch matches

|===

.Switch Branch
[cols="1,1e,3",grid=rows,frame=all]
|===
| Property | Type | Description

| Condition
| Rex
| Branch match condition

| Value
| Rex
| Branch return expression

|===


=== Collections

A collection expression represents a bag or array with expression elements.

.Collection Rex Variants
[cols="1,5a",grid=rows,frame=all]
|===
| Variant | Definition

| Bag
|
[cols="1,1e,3",grid=rows,frame=none]
!===
! Property ! Type ! Description

! Values ! List<Rex> ! Collection elements
!===

| Array
|
[cols="1,1e,3",grid=rows,frame=none]
!===
! Property ! Type ! Description

! Values ! List<Rex> ! Collection elements
!===

|===

==== Tuple

A tuple expression represents a tuple whose key-value pairs are expression pairs.

.Tuple Rex
[cols="1,1e,3",grid=rows,frame=all]
|===
| Property | Type | Description

| Fields
| List<Field>
| Tuple field expressions

|===

.Tuple Field
[cols="1,1e,3",grid=rows,frame=all]
|===
| Property | Type | Description

| Name
| Rex~string~
| Field name (string-valued) expression

| Value
| Rex
| Field value

|===

==== Queries

In PartiQL, SELECT-FROM-WHERE queries are expressions and can be composed with other expressions via relation-value projections. The following operators define projections from relations to values which are composable with expressions of _Exp_. These projections are used to map from relations to either scalar values or collections of arbitrary values. These operators correspond to subqueries, xref:index.adoc#pivot_clause[PIVOT], and xref:index.adoc#select_value[SELECT VALUE].

.Query Rex Variants
[cols="1,5a",grid=rows,frame=all]
|===
| Variant | Definition

| Collection
|

A collection query expression is an expression which wraps a relation expression to produce a collection _V~collection~_. There are no constraints on the number of tuples or fields. A collection subquery expression can be used as the right-hand-side argument of the `IN` predicate; or as the left (or right) side of a collection comparison function. Note that _R ⊊ V~collection~_ 

[cols="1,1e,3",grid=rows,frame=none]
!===
! Property ! Type ! Description

! Input ! Rel ! Input relation expression
! Constructor ! Rex ! Constructor expression

!===

| Scalar
|

A scalar subquery expression is a simple expression that wraps a relation expression. The coercion rules are specified by the xref:scalar_subquery[scalar subquery] section of PartiQL Query semantics. In short, this projection is the function `COLL_TO_SCALAR`. If the input to `COLL_TO_SCALAR` is a collection consisting of a single tuple with a single field, the field's value is projected; otherwise a cardinality expection is thrown (MISSING in permissive mode).

[cols="1,1e,3",grid=rows,frame=none]
!===
! Property ! Type ! Description

! Input ! Rel ! Input relation expression to be coerced
!===


| Pivot
|

The pivot expression returns a single tuple whose fields are constructed from the input relation; see xref:pivot_clause[PIVOT] for details.

[cols="1,1e,3",grid=rows,frame=none]
!===
! Property ! Type ! Description

! Input
! Rel
! Input relation expression

! Key
! Exp~string~
! Field key mapping expression

! Value
! Exp
! Field value mapping expression

!===

|===

=== Rel

.Rel Variants
[cols="1e,5a",grid=rows,frame=all]
|===

| scan
| ..

| scan_indexed
| ..

| unpivot
| ..

| distinct
| ..

| filter
| ..

| sort
| ..

| union
| ..

| intersect
| ..

| except
| ..

| limit
| ..

| offset
| ..

| project
| ..

| join
| ..

| aggregate
| ..

| exclude
| ..

|===

IMPORTANT: The below sections have not been updated.

[#rel_op_scan]
=== Scan

The Scan Operator is a simple operator which produces a relation from a value; it represents a xref:single_item_from_clause[single-item FROM clause]. The Scan Operator maintains the input collection expression's orderedness.

[NOTE,caption=signature]
====
_V~collection~ → R_
====

[cols="1,1e,1,4",grid=rows,frame=all]
|===
| Property | Type | Required | Description

| Input
| Rex~collection~
| Required
| A collection value expression — e.g. bag or array

| As Alias
| V~symbol~
| Optional
| Binding name for each value of the collection

| At Alias
| V~symbol~
| Optional
| Binding name for the index of each value of the collection only if it is an array

|===

[#rel_op_]
=== Cross

The Cross Operator produces the https://en.wikipedia.org/wiki/Cartesian_product:[Cartesian Product] of two relations; it represents a xref:multi_item_from_clause[multi-item FROM clause] as well as a CROSS JOIN. Note that output bindings from the left-hand-side relation (LHS) are in scope for expressions in the right-hand-side (RHS). The output relation of a Cross Operator is unordered. 

[NOTE,caption=signature]
====
_R x R → R_
====

[cols="1,1e,1,4",grid=rows,frame=all]
|===
| Property | Type | Required | Description

| Input~LHS~
| Rel
| Required
| The left-hand-side input relation expression

| Input~RHS~
| Rel
| Required
| The right-hand-side input relation expression

|===

[#rel_op_filter]
=== Filter

The Filter Operator produces a new relation by selecting all tuples of its input relation where the _condition_ is TRUE. The Filter Operator maintains the orderdness of the input relation.

[NOTE,caption=signature]
====
_R → R_
====

[cols="1,1e,1,4",grid=rows,frame=all]
|===
| Property | Type | Required | Description

| Input
| Rel
| Required
| Relation expression to filter

| Condition
| Rex~bool~
| Required
| A boolean value expression

|===

[#rel_op_project]
=== Project

The Relation Projection Operator corresponds to the xref:sql_select_clause[SQL SELECT Clause]. It produces a new relation by applying each projection expression to the input relation's tuples. That is, the Relation Projection Operator creates tuples by evaluating all binding expressions values on the input tuple and adding the results to the corresponding binding expression names in the output tuple.

[NOTE,caption=signature]
====
_R → R_
====

[cols="1,1e,1,4",grid=rows,frame=all]
|===
| Property | Type | Required | Description

| Input
| Rel
| Required
| Input relation expression

| Projections
| List<Rex>
| Required
| A collection of binding expressions

|===

[#rel_op_aggregate]
=== Aggregate

The Aggregate Operator produces a new relation by aggregating the input relation into groups based upon the operator's aggregation functions and grouping expressions. Additionally, an aggregation operator can project all values of each group into a specified AS key — for details see the xref:group_by_clause[GROUP BY Clause]. This operator does not maintain orderedness.

[NOTE,caption=signature]
====
_R → R_
====

[cols="1,1e,1,3",grid=rows,frame=all]
|===
| Property | Type | Required | Description

| Input
| Rel
| Required
| Relation Expression to aggregate

| Aggregations
| List of Aggregate Calls
| Optional
| A list of aggregate function calls

| Groups
| List<Rex~text~>
| Optional
| A list of group by keys; required if aggregations list is empty

| As Alias
| V~symbol~
| Optional
| The GROUP ... AS alias

|===

[#rel_op_set]
=== Set

The Set Operator produces a relation by performing the specified set (or bag) operator on the input relations. This operator does not maintain the orderedness of either the left or right hand relation expressions.

[NOTE,caption=signature]
====
_R → R_
====

[cols="1,1e,1,4",grid=rows,frame=all]
|===
| Property | Type | Required | Description

| Input~LHS~
| Rel
| Required
| The left-hand-side input relation expression

| Input~RHS~
| Rel
| Required
| The right-hand-side input relation expression

| Type
| Set Op
| Required
| UNION, INTERSECT, EXCEPT

| Filter
| Rel Filter
| Optional
| ALL (default), DISTINCT

|===

[#rel_op_sort]
=== Sort

The Sort Operator will sort the input relation expression by the given sort specifications.

[NOTE,caption=signature]
====
_R → R_
====

[cols="1,1e,1,4a",grid=rows,frame=all]
|===
| Property | Type | Required | Description

| Input
| Rel
| Required
| Relation expression to sort

| Specs
| List of Sort Specs
| Required
| A list of specifications to sort on
|===

// TODO note on ASC / DESC defaults with NULL ordering defaults
// ASC NULLS LAST / DESC NULLS FIRST

.Sort Spec
[grid=rows,frame=all]
|===
| Property | Type

| Value
| Rex

| Dir
| ASC, DESC

| Null Dir
| FIRST, LAST
|===

[#rel_op_fetch]
==== Fetch

The Fetch Operator is responsible for limiting the number of tuples in an relation. Optionally, an offset number of tuples can be provided. This corresponds to the SQL FETCH clause (F431), but PartiQL does not currently support FETCH and provides the familiar xref:fetch_clause[LIMIT ... OFFSET Clause] as an alternative. 

[NOTE,caption=signature]
====
_R → R_
====

[cols="1,1e,1,4",grid=rows,frame=all]
|===
| Property | Type | Required | Description

| Input
| Rel
| Required
| Input relation expression to limit

| Limit
| Rex~numeric~
| Required
| Number of tuples to return in the output

| Offset
| Rex~numeric~
| Optional
| Number of tuples to offset in the input

|===

[#rel_op_join]
=== Join

The Join Operator represents traditional xref:https://en.wikipedia.org/wiki/Relational_algebra#Joins_and_join-like_operators[Relational Algebra joins] and corresponds to the join variants of the xref:multi_item_from_clause[multi-item FROM clause]. To be continued.

[NOTE,caption=signature]
====
_R → R_
====

[cols="1,1e,1,4",grid=rows,frame=all]
|===
| Property | Type | Required | Description

| Input~LHS~
| Rel
| Required
| The left-hand-side input relation expression

| Input~RHS~
| Rel
| Required
| The right-hand-side input relation expression

| Type
| Join Type
| Required
| INNER, LEFT, RIGHT, FULL

| Condition
| Rex~bool~
| Optional
| Join condition

// I don't know if anyone is reading the notes, but ...
// It's somewhat compact to say there's "one" join operator with an optional condition
// But in implementations, you might have variants like equijoin and theta join
// I didn't feel the need to make a distinction here

|===
