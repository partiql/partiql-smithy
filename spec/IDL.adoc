= Interface Definition Language
:toc:
:toc-title: Page Contents
:sectlinks:

include::navigation.adoc[]

== About

This document defines an interface definition language with an Ion serialization. It is intended to be a simple language for modeling interfaces from which it is easy to build code generators i.e. 'POJOs' and serializers/deserializers.

This language is easily translated to Ion Schema; as that is the standard Ion interface definition language. So why not Ion Schema? Primarily for ease of manipulating and reasoning from highly constrained type definitions. Reducing the allowable type definitions greatly simplifies building the necessary tooling. You'll find the modeling capabilities are far less than that of Ion Schema, but are quite similar to the type modeling of OpenAPI / Swagger, Protobuf, Smithy, and Avro.


=== Scope

I am interested in the following topics, but I have left them out-of-scope for the initial review.

.Out of Scope
* Optional fields
* Schema evolution and versioning
* Open content
* Type constraints

=== Notation

This document uses the xref:https://github.com/antlr/antlr4/blob/master/doc/grammars.md[ANTLR grammar notation] to define the IDL.

== Interface Definition Language

The syntax is an amalgamation of C typedef and Rust type aliases. Type constraints are out-of-scope, but I will show in the proposed extensions that this syntax lends itself to constraints.

=== Basic Example

This short example showcases the interface modeling capabilities.

[source]
----
type lat_t decimal;
type lon_t decimal;

type coordinates struct {
    lat: lat_t;
    lon: lon_t;
};
----

=== Document

[source,antlr]
----
document
    : include* definition*
    ;

include
    : 'include' string ';'
    ;

identifier: [a-z][a-z_]*;

definition
    : 'type' identifier type ';'
    ;

type
    : identifier
    | primitive
    | container
    | udt
    ;
----

=== Primitive Types

[source,antlr]
----
primitive
    : 'bool'
    | 'i32'     // 32-bit signed integer
    | 'i64'     // 64-bit signed integer
    | 'f32'     // IEEE 754 (32 bit)
    | 'f64'     // IEEE 754 (64 bit)
    | 'decimal' // Decimal-encoded real numbers
    | 'char'    // Unicode character
    | 'string'  // Unicode character sequence of variable length
    | 'byte'    // Byte
    | 'bytes'   // Byte sequence of variable length
    | ion       // Raw Ion value
    ;

ion
    : 'ion'
    | 'ion.bool'
    | 'ion.int'
    | 'ion.float'
    | 'ion.decimal'
    | 'ion.timestamp'
    | 'ion.string'
    | 'ion.symbol'
    | 'ion.blob'
    | 'ion.clob'
    | 'ion.struct'
    | 'ion.list'
    | 'ion.sexp'
    ;
----

=== Container Types

[source,antlr]
----
container
    : list
    | map
    | tuple
    | array
    ;
----

==== List

[source,antlr]
----
list : 'list' '<' type '>';
----

.Example
[source]
----
type my_list list<bool>;
----

==== Map

[source,antlr]
----
map : 'map' '<' primitive ',' type '>';
----

.Example
[source]
----
type my_map map<i32,string>;
----

==== Tuple

[source,antlr]
----
tuple
    : '(' type (',' type)* ')'
    ;
----

.Example
[source]
----
type point (i32, i32, i32);
----

==== Array

Define an array of primitives with a fixed length.

[source,antlr]
----
array
    : primitive '[' integer ']'
    ;
----

.Example
[source,ion]
----
type uuid byte[16];
----

=== User-Defined Types

[source,antlr]
----
definition
    : struct
    | union
    | enum
    | unit
    ;
----

==== Struct

[source,antlr]
----
struct : 'struct' '{' field+ '}';

field: identitifer ':' type ';';
----

.Example
[source,ion]
----
type coordinates struct {
    lat: decimal;
    lon: decimal;
};
----

==== Union

[source,antlr]
----
union
    : 'union' '{' variant+ '}'
    ;

variant
    : identifier type
    ;
----

.Example
[source,ion]
----
type my_union union {
    variant_a struct {
        x: int32;
        y: int32;
    };
    variant_b stuct {
        u: int32;
        v: int32;
    };
};
----

==== Enum

[source,ion]
----
enum : 'enum' { enumerator (',' enumerator)* '}'

enumerator : [A-Z]+
----

.Example
[source,ion]
----
enum my_enum { A, B, C }
----

==== Unit

Define a type which is represented by only its name. This is like an empty struct and is represented by an Ion symbol.

[source,antlr]
----
unit : 'unit'
----

.Example
[source]
----
type my_singleton unit;
----

== Amazon Ion

This section defines how type definitions are mapped to Ion values as well as Ion schema. For details on Ion, see xref:https://amazon-ion.github.io/ion-docs/docs/spec.html[Ion Specification].

=== (END OF DOCUMENT) Ion Encoding

IMPORTANT: The below sections have not been updated.

==== Primitives

Primitive IDL types are encoded via the Ion types shown in the table.

|===
| IDL Type | Ion Type

| bool | bool
| i32 | int
| i64 | int
| f32 | float
| f64 | float
| decimal | decimal
| char | string
| string | string
| byte | blob
| bytes | blob
| ion | any
| ion._type_ | _type_

|===

==== Collections

**List**

A list is encoded an Ion list.

**Map**

A map is encoded as an Ion list whose values are key-value pair s-expressions. For example,

[source,ion]
----
map<i32,string>

// The map value { 0: "a", 1: "b" } is encoded as

[(0 "a"),(1 "b")]
----

==== User-Defined Types

All type names are serialized as quoted Ion symbols and are fully-qualified using "." as a delimiter.

.Example
[source,ion]
----
// Definition
(record outer
  x::bool
  y::bool

  (record inner
    a::int32
    b::int32
  )
)

// Names
'outer'
'outer.inner'
----

**Product**

A product type is serialized as an Ion s-expression where the name symbol is the head and the operands are the tail.

[source,ion]
----
// Definition
(product coordinates
    lat::decimal
    lon::decimal
)

// Example
(coordinates 47.6205 122.3493)
----

**Sum**

A sum type takes on one of several variants. There is no serialization for a sum type, only one of its variants.
As of now, only product types are allowed as variants of a sum type.

**Enum**

Enum types are serialized as Ion symbols, using the value as a name.

.Example
----
// Definition
(enum example (A, B))

// Example
'example.A'
'example.B'
----

**Fixed**

A fixed type is serialized as an Ion blob whose length is determined by the fixed type size.

**Unit**

A unit is serialized to Ion with its name as a symbol.

.Example
[source,ion]
----
(unit my_type)

// ion encoding
'my_type'
----

=== Ion Schema

PLACEHOLDER

== Appendix

=== A1 — Constraints

PLACEHOLDER

=== A2 — Complete Grammar

PLACEHOLDER

==== Reserved Words

[source]
----
bool
i32
i64
f32
f64
string
bytes
ion

list
map

struct
union
enum
fixed
unit
----

== License

This project is licensed under the Apache-2.0 License.
