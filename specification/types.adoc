= PartiQL Schema
:toc:
:toc-title: Page Contents
:sectlinks:

// include::parts.adoc[]

[#types]
== Types

.Boolean Type
[cols="1m,3,>2",grid=rows,frame=all]
|===
| Type | Description | Values

| bool
| Boolean value
| `TRUE` or `FALSE`

|===

.Numeric Types
[cols="1m,3,>2a",grid=rows,frame=all]
|===
| Type | Description | Range

| int8
| Signed integer that can be stored in one byte
| -128 to +127

| int16
| Signed integer that can be stored in two bytes
| -32768 to +32767

| int32
| Signed integer that can be stored in four bytes
| -2147483648 to +2147483647

| int64
| Signed integer that can be stored in eight bytes
| -9223372036854775808 to +9223372036854775807 

| big_int
| Signed integer of arbitrary size (Ion int)
| ...

| big_decimal
| Exact numeric type with arbitrary precision (Ion decimal)
| ...

| float32
| Single-precision, binary floating point (IEEE 754 32-bit)
| ...

| float64
| Double-precision, binary floating point (IEEE 754 64-bit)
| ...

| decimal(p,s)
| Exact numeric with fixed precision _p_ and scale _s_
| ...

|===

.Character String Types
[cols="1m,5",grid=rows,frame=all]
|===
| Type | Description

| char_fixed(n)
| Unicode codepoint sequence of fixed length _n_

| char_varying(n)
| Unicode codepoint sequence of variable length up to _n_

| string
| Unicode codepoint sequence of arbitrary length

| symbol
| Unicode codepoint sequences of arbitrary length. The primary difference is the intended semantics: symbols represent case-sensitive identifiers as opposed to textual literal values.

|===

.Bit String Types
[cols="1m,5",grid=rows,frame=all]
|===
| Type | Description

| bit_fixed(n)
| Bit string of fixed length _n_

| bit_varying(n)
| Bit string of variable length up to _n_ 

| binary
| Bit string of arbitrary length

|===

.Byte String Types
[cols="1m,5",grid=rows,frame=all]
|===
| Type | Description

| byte_fixed(n)
| Octet string of fixed length _n_

| byte_variable(n)
| Octet string of variable length up to _n_ 

| blob
| Octet string of arbitrary length

| clob
| Unicode codepoint sequence of arbitrary length

|===

.Date/Time Types
[cols="1m,5",grid=rows,frame=all]
|===
| Type | Description

| date
| A date with no _time_

| time(p)
| A _date_-less time with seconds precision _p_ and no time zone offset

| time_tz(p,z)
| A _date_-less time with seconds precision _p_ and time zone offset _z_

| time_arbitrary
| A _date_-less time with arbitrary precision and no time zone offset

| timestamp(p)
| A _date_ and _time_ with seconds precision _p_ and no time zone offset

| timestamp_tz(p,z)
| A _date_ and _time_ with seconds precision _p_ and time zone offset _z_

| timestamp_arbitrary
| A _date_ and _time_ with arbitrary precision

// Open Question: Should we model timestamp that only has UTF offsets which are a strict subset of timezones.

// SQL-99 4.7.2
| interval(p)
| A time interval with seconds precision _p_

2+a| NOTE: A time zone offset _z_ is an hour/minute pair of integers

|===

.Collection Types
[cols="1m,5",grid=rows,frame=all]
|===
| Type | Description

| bag
| Unordered collection of values

| list
| Ordered collection of values

| sexp
| Ordered collection of values with user-defined semantics

|===

.Struct Type
[cols="1m,5",grid=rows,frame=all]
|===
| Type | Description

| struct
| Unordered collection of unconstrained fields

2+a|  NOTE: Fields are name-value pairs where names are strings

|===

.Absent Types
[cols="1m,3,>2m",grid=rows,frame=all]
|===
| Type | Description | Value

| null
| Type of the null value
| NULL

| missing
| Type of the missing value
| MISSING

| unknown
2+| The empty type

|===

.Graph Type
[grid=rows,frame=all]
|===
| Description

| Placeholder â€” https://github.com/partiql/partiql-docs/blob/main/RFCs/0025-graph-data-model.md

|===

.Union Types
[cols="1m,5",grid=rows,frame=all]
|===

2+a|
NOTE: Let `(t~0~\|...\|t~n~)` represent the union of types t~0~,...,t~n~ 

s| Type s| Description

| any
| The union of all types

| lob
| `(blob\|clob)`

| number
| `(exact\|approximate)`

| exact
| `(int8\|int16\|int32\|int64\|int\|decimal)`

| approximate
| `(float32\|float64)`

| text
| `(char\|string\|symbol)`

|===

== Shapes

PLACEHOLDER.

The term _shape_ refers to the static constraints of data. It is akin to the common term _schema_, but in the context of database systems this term is overloaded, and we have opted for a less ambiguous term. Additionally, _shapes_ are more flexible than schemas from relational systems. We have seen this term in similar data systems such as xref:https://zed.brimdata.io/docs[Zed] from Brim Data. 

== Data Definition Language (DDL)

PLACEHOLDER.

== Appendix

include::appendices/serialization.adoc["PartiQL Type Serialization"]
